{
  "hash": "a6197722e16a671637302934dfea780c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Conformal Prediction Beyond Exchangeability\"\ndescription: |\n  Replicating empirical examples from <a href=\"https://projecteuclid.org/journals/annals-of-statistics/volume-51/issue-2/Conformal-prediction-beyond-exchangeability/10.1214/23-AOS2276.full\">Conformal Prediction Beyond Exchangeability\n  by Barber, et al.</a>\ndate: \"7/25/2024\"\nformat:\n  html:\n    toc: false\n    toc-location: right\n    code-overflow: scroll\nexecute: \n  freeze: true\npage-layout: full\ncategories: [Conformal Prediction]\nimage: \"./thumbnail.jpg\"\n---\n\n\n\n\n### Dependencies\n\n::: {#cb06fc33 .cell execution_count=1}\n``` {.python .cell-code}\nfrom great_tables import GT, md\nimport numpy as np\nimport numpy.typing as npt\nimport pandas as pd\nfrom pathlib import Path\nimport plotnine as pn\nimport statsmodels.api as sm\nfrom tqdm import tqdm\nfrom typing import Any, Callable, List\n\nbase_dir = Path().cwd()\ngenerator = np.random.default_rng()\n```\n:::\n\n\n### Data\n\n::: {#5d342d25 .cell execution_count=2}\n``` {.python .cell-code}\n# Electricity data\nelectricity = pd.read_csv(base_dir / \"data\" / \"electricity-normalized.csv\")\nelectricity = (\n    electricity\n    .iloc[17760:]\n    .assign(period=lambda x: x.period*24)\n    .loc[lambda df: (df[\"period\"] >= 9) & (df[\"period\"] <= 12)]\n    [[\"transfer\", \"nswprice\", \"vicprice\", \"nswdemand\", \"vicdemand\"]]\n    .reset_index(drop=True)\n)\npermuted = electricity.sample(frac=1).reset_index(drop=True)\n\n# Function to generate simulated data\ndef sim_data(N: int, d: int, setting: int) -> tuple[pd.DataFrame, npt.NDArray]:\n    X = np.random.multivariate_normal(mean=np.zeros(d), cov=np.eye(d), size=N)\n    if setting == 1:\n        beta = np.array([2, 1, 0, 0])\n        y = X @ beta + np.random.normal(0, 1, N)\n        X = pd.DataFrame(X, columns=[f\"feature_{i+1}\" for i in range(d)])\n    elif setting == 2:\n        beta_1 = np.array([2, 1, 0, 0])\n        beta_2 = np.array([0, -2, -1, 0])\n        beta_3 = np.array([0, 0, 2, 1])\n        y = np.zeros(N)\n        # Generate y for different segments\n        y[:500] = X[:500] @ beta_1 + np.random.normal(0, 1, 500)\n        y[500:1500] = X[500:1500] @ beta_2 + np.random.normal(0, 1, 1000)\n        y[1500:] = X[1500:] @ beta_3 + np.random.normal(0, 1, 500)\n        X = pd.DataFrame(X, columns=[f\"feature_{i+1}\" for i in range(d)])\n    else:\n        beta_start = np.array([2, 1, 0, 0])\n        beta_end = np.array([0, 0, 2, 1])\n        beta = np.linspace(beta_start, beta_end, N)\n        y = np.array([X[i] @ beta[i] + np.random.normal(0, 1) for i in range(N)])\n        X = pd.DataFrame(X, columns=[f'feature_{i+1}' for i in range(d)])\n    return (X, y)\n```\n:::\n\n\n### Functions\n\nThe `nexcp_split` function implements non-exchangeable split conformal prediction (CP).\nHowever, we can force it to also implement standard CP,\nwhich assumes exchangeability, by setting uniform weights. So we only need one \nfunction to replicate the results!\n\n::: {#2ad8e52d .cell execution_count=3}\n``` {.python .cell-code}\ndef normalize_weights(weights: npt.NDArray):\n    return weights / weights.sum()\n\n\ndef nexcp_split(\n    model: Callable[[npt.NDArray, pd.DataFrame, npt.NDArray], Any],\n    split_function: Callable[[int], npt.NDArray],\n    y: npt.NDArray,\n    X: pd.DataFrame,\n    tag_function: Callable[[int], npt.NDArray],\n    weight_function: Callable[[int], npt.NDArray],\n    alpha: float,\n    test_index: int\n):\n    \"\"\"Implements non-exchangeable split conformal prediction\"\"\"\n    \n    # Pull test observation from data\n    y_test = y[test_index]\n    X_test = X.iloc[[test_index]]\n    # Select all observations up to that point\n    y = y[:test_index]\n    X = X.iloc[:test_index]\n    # Generate indices for train/calibration split\n    split_indices = split_function(test_index)\n    # Split data, tags, and weights\n    X_train = X.iloc[split_indices]\n    y_train = y[split_indices]\n    X_calib = X.drop(split_indices)\n    y_calib = np.delete(y, split_indices)\n    # Generate tags and weights\n    tags_train = tag_function(len(X_train)-1)\n    weights_calib = normalize_weights(weight_function(len(X_calib)-1))\n    # Train model\n    model_base = model(y_train, X_train, weights=tags_train)\n    model_fitted = model_base.fit()\n    # Generate residuals\n    residuals = np.abs(y_calib - model_fitted.predict(X_calib))\n    # Calculate weighted quantile of residuals\n    q_hat = np.quantile(\n        residuals,\n        1 - alpha,\n        weights=weights_calib,\n        method=\"inverted_cdf\"\n    )\n    # Calculate predicted value\n    y_hat = model_fitted.predict(X_test).iloc[0]\n    # Generate CI\n    lb = y_hat - q_hat\n    ub = y_hat + q_hat\n    covered = lb <= y_test <= ub\n    return {\"ci\": np.array([lb, y_hat, ub]), \"covered\": covered, \"width\": ub-lb}\n\n\ndef plot_rolling_coverage(\n    results: List[dict],\n    alpha: float = 0.1,\n    window: int = 300,\n    rows: int = 2,\n    repeated: bool = False\n):\n    \"\"\"Plot the algorithm's mean coverage over a sliding window\"\"\"\n\n    coverage_df = pd.DataFrame(results)\n    if repeated:\n        coverage_df = (\n            coverage_df\n            .groupby([\"method\", \"dataset\", \"index\"])[\"covered\"]\n            .mean()\n            .reset_index()\n        )\n    coverage_df[\"coverage_mean\"] = (\n        coverage_df\n        .groupby([\"method\", \"dataset\"])[\"covered\"]\n        .transform(lambda x: x.rolling(window=window).mean())\n    )\n    coverage_df[\"time\"] = coverage_df.groupby([\"method\", \"dataset\"]).cumcount() + 1\n    coverage_df = coverage_df.dropna(subset=[\"coverage_mean\"])\n    coverage_plot = (\n        pn.ggplot(\n            coverage_df,\n            pn.aes(x=\"time\", y=\"coverage_mean\", color=\"method\", group=\"method\")\n        )\n        + pn.geom_line()\n        + pn.geom_hline(yintercept=1-alpha, linetype=\"solid\")\n        + pn.scale_y_continuous(limits=(0, 1))\n        + pn.facet_wrap(\"~ dataset\", nrow=rows, scales=\"free\")\n        + pn.theme_538()\n        + pn.labs(x=\"Time\", y=\"Coverage\", color=\"Method\")\n    )\n    return coverage_plot\n\n\ndef plot_rolling_width(\n    results: dict,\n    window: int = 300,\n    rows: int = 2,\n    repeated: bool = False\n):\n    \"\"\"Plot the algorithm's mean prediction interval width over a sliding window\"\"\"\n\n    width_df = pd.DataFrame(results)\n    if repeated:\n        width_df = (\n            width_df\n            .groupby([\"method\", \"dataset\", \"index\"])[\"width\"]\n            .mean()\n            .reset_index()\n        )\n    width_df[\"width_mean\"] = (\n        width_df\n        .groupby([\"method\", \"dataset\"])[\"width\"]\n        .transform(lambda x: x.rolling(window=window).mean())\n    )\n    width_df[\"time\"] = width_df.groupby([\"method\", \"dataset\"]).cumcount() + 1\n    width_df = width_df.dropna(subset=[\"width_mean\"])\n    width_plot = (\n        pn.ggplot(\n            width_df,\n            pn.aes(x=\"time\", y=\"width_mean\", color=\"method\", group=\"method\")\n        )\n        + pn.geom_line()\n        + pn.facet_wrap(\"~ dataset\", nrow=rows, scales=\"free\")\n        + pn.theme_538()\n        + pn.labs(x=\"Time\", y=\"Width\", color=\"Method\")\n    )\n    return width_plot\n```\n:::\n\n\n### Electricity example\n\nNote: I implement non-exchangeable split CP with least-squares by using WLS and setting\nall the tags to a uniform value. Standard CP is implemented by setting all the weights\nto a uniform value as mentioned above.\n\n::: {#c94b6ce3 .cell execution_count=4}\n``` {.python .cell-code}\nsplit_fn = lambda x: np.sort(generator.choice(x, int(np.floor(x*0.7)), replace=False))\nresults = []\n\n# Create X and y for the normal and permuted data\nX, y = (electricity.drop(\"transfer\", axis=1), electricity[\"transfer\"].to_numpy())\nX_perm, y_perm = (permuted.drop(\"transfer\", axis=1), permuted[\"transfer\"].to_numpy())\n\n# Predict for each observation from N=100 to N=len(electricity)\nfor i in tqdm(range(100, len(electricity)), total=len(electricity)-100):\n    for method in [\"NexCP+LS\", \"NexCP+WLS\", \"CP+LS\"]:\n        for dataset in [\"Electricity\", \"Permuted\"]:\n            if dataset == \"Electricity\":\n                X_model, y_model = (X, y)\n            else:\n                X_model, y_model = (X_perm, y_perm)\n            if method == \"NexCP+LS\":\n                tag_fn = lambda x: np.array([1.]*(x + 1))\n                weight_fn = lambda x: 0.99**np.arange(x, -1, -1)\n            elif method == \"NexCP+WLS\":\n                tag_fn = lambda x: 0.99**np.arange(x, -1, -1)\n                weight_fn = tag_fn\n            else:\n                tag_fn = lambda x: np.array([1.]*(x + 1))\n                weight_fn = tag_fn\n            out = nexcp_split(\n                model=sm.WLS,\n                split_function=split_fn,\n                y=y_model,\n                X=X_model,\n                tag_function=tag_fn,\n                weight_function=weight_fn,\n                alpha=0.1,\n                test_index=i\n            )\n            out[\"method\"] = method\n            out[\"dataset\"] = dataset\n            out[\"index\"] = i\n            del out[\"ci\"]\n            results.append(out)\n```\n:::\n\n\n#### Plots\n\n::: {#2ba9c302 .cell layout-ncol='2' execution_count=5}\n``` {.python .cell-code}\ncoverage_plot = plot_rolling_coverage(results, alpha=0.1, window=300)\ncoverage_plot.show()\n\nwidth_plot = plot_rolling_width(results, window=300)\nwidth_plot.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-6-output-1.png){width=640 height=480 fig-align='center'}\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-6-output-2.png){width=640 height=480 fig-align='center'}\n:::\n:::\n\n\n#### Table\n\n::: {#c5fd7505 .cell execution_count=6}\n``` {.python .cell-code}\ntable = (\n    pd\n    .DataFrame(results)\n    .groupby([\"method\", \"dataset\"])\n    .mean()\n    .reset_index()\n)\ntable = (\n    table\n    .pivot_table(\n        index='method',\n        columns='dataset',\n        values=['covered', 'width']\n    )\n)\ntable.columns = [f'{col[0]}_{col[1].lower()}' for col in table.columns]\ntable = table.reset_index()\ntable = (\n    GT(table, rowname_col=\"method\")\n    .tab_spanner(\n        label=\"Electricity data\",\n        columns=[\"covered_electricity\", \"width_electricity\"]\n    )\n    .tab_spanner(\n        label=\"Permuted electricity data\",\n        columns=[\"covered_permuted\", \"width_permuted\"]\n    )\n    .fmt_number(\n        columns = [\n            \"covered_electricity\",\n            \"width_electricity\",\n            \"covered_permuted\",\n            \"width_permuted\"\n        ],\n        decimals=3\n    )\n    .cols_label(\n        covered_electricity = \"Coverage\",\n        width_electricity = \"Width\",\n        covered_permuted = \"Coverage\",\n        width_permuted = \"Width\"\n    )\n)\ntable.show()\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div id=\"rnipgvklog\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>\n#rnipgvklog table {\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n          -webkit-font-smoothing: antialiased;\n          -moz-osx-font-smoothing: grayscale;\n        }\n\n#rnipgvklog thead, tbody, tfoot, tr, td, th { border-style: none; }\n tr { background-color: transparent; }\n#rnipgvklog p { margin: 0; padding: 0; }\n #rnipgvklog .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; }\n #rnipgvklog .gt_caption { padding-top: 4px; padding-bottom: 4px; }\n #rnipgvklog .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; }\n #rnipgvklog .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; }\n #rnipgvklog .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; }\n #rnipgvklog .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; }\n #rnipgvklog .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; }\n #rnipgvklog .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; }\n #rnipgvklog .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; }\n #rnipgvklog .gt_column_spanner_outer:first-child { padding-left: 0; }\n #rnipgvklog .gt_column_spanner_outer:last-child { padding-right: 0; }\n #rnipgvklog .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; }\n #rnipgvklog .gt_spanner_row { border-bottom-style: hidden; }\n #rnipgvklog .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; }\n #rnipgvklog .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; }\n #rnipgvklog .gt_from_md> :first-child { margin-top: 0; }\n #rnipgvklog .gt_from_md> :last-child { margin-bottom: 0; }\n #rnipgvklog .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; }\n #rnipgvklog .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; }\n #rnipgvklog .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; }\n #rnipgvklog .gt_row_group_first td { border-top-width: 2px; }\n #rnipgvklog .gt_row_group_first th { border-top-width: 2px; }\n #rnipgvklog .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; }\n #rnipgvklog .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; }\n #rnipgvklog .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; text-align: left; }\n #rnipgvklog .gt_left { text-align: left; }\n #rnipgvklog .gt_center { text-align: center; }\n #rnipgvklog .gt_right { text-align: right; font-variant-numeric: tabular-nums; }\n #rnipgvklog .gt_font_normal { font-weight: normal; }\n #rnipgvklog .gt_font_bold { font-weight: bold; }\n #rnipgvklog .gt_font_italic { font-style: italic; }\n #rnipgvklog .gt_super { font-size: 65%; }\n #rnipgvklog .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; }\n #rnipgvklog .gt_asterisk { font-size: 100%; vertical-align: 0; }\n \n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n\n<tr class=\"gt_col_headings gt_spanner_row\">\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"2\" colspan=\"1\" scope=\"col\" id=\"\"></th>\n  <th class=\"gt_center gt_columns_top_border gt_column_spanner_outer\" rowspan=\"1\" colspan=\"2\" scope=\"colgroup\" id=\"Electricity data\">\n    <span class=\"gt_column_spanner\">Electricity data</span>\n  </th>\n  <th class=\"gt_center gt_columns_top_border gt_column_spanner_outer\" rowspan=\"1\" colspan=\"2\" scope=\"colgroup\" id=\"Permuted electricity data\">\n    <span class=\"gt_column_spanner\">Permuted electricity data</span>\n  </th>\n</tr>\n<tr class=\"gt_col_headings\">\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"Coverage\">Coverage</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"Width\">Width</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"Coverage\">Coverage</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"Width\">Width</th>\n</tr>\n<tbody class=\"gt_table_body\">\n  <tr>\n    <th class=\"gt_row gt_left gt_stub\">CP+LS</th>\n    <td class=\"gt_row gt_right\">0.851</td>\n    <td class=\"gt_row gt_right\">0.562</td>\n    <td class=\"gt_row gt_right\">0.900</td>\n    <td class=\"gt_row gt_right\">0.636</td>\n  </tr>\n  <tr>\n    <th class=\"gt_row gt_left gt_stub\">NexCP+LS</th>\n    <td class=\"gt_row gt_right\">0.872</td>\n    <td class=\"gt_row gt_right\">0.586</td>\n    <td class=\"gt_row gt_right\">0.897</td>\n    <td class=\"gt_row gt_right\">0.629</td>\n  </tr>\n  <tr>\n    <th class=\"gt_row gt_left gt_stub\">NexCP+WLS</th>\n    <td class=\"gt_row gt_right\">0.906</td>\n    <td class=\"gt_row gt_right\">0.552</td>\n    <td class=\"gt_row gt_right\">0.901</td>\n    <td class=\"gt_row gt_right\">0.627</td>\n  </tr>\n</tbody>\n\n\n</table>\n\n</div>\n        \n```\n:::\n:::\n\n\n### Simulated example\n\nThis demonstrates the conformal prediction algorithm in the following data settings:\ni.i.d. data, data generating process with changepoints, and data with distribution drift.\nIn the paper they repeat this 200 times to smooth the estimates, but for computational\npurposes here I only repeated it 50 times.\n\n::: {#d54052c6 .cell execution_count=7}\n``` {.python .cell-code}\nsplit_fn = lambda x: np.sort(generator.choice(x, int(np.floor(x*0.7)), replace=False))\nresults = []\n\n# Predict for each observation from N=100 to N=len(electricity)\nfor i in tqdm(range(100, 2000), total=2000-100):\n    for rep in range(50):\n        for method in [\"NexCP+LS\", \"NexCP+WLS\", \"CP+LS\"]:\n            for dataset in [\"setting_1\", \"setting_2\", \"setting_3\"]:\n                if dataset == \"setting_1\":\n                    X_model, y_model = sim_data(2000, 4, setting=1)\n                elif dataset == \"setting_2\":\n                    X_model, y_model = sim_data(2000, 4, setting=2)\n                else:\n                    X_model, y_model = sim_data(2000, 4, setting=3)\n                if method == \"NexCP+LS\":\n                    tag_fn = lambda x: np.array([1.]*(x + 1))\n                    weight_fn = lambda x: 0.99**np.arange(x, -1, -1)\n                elif method == \"NexCP+WLS\":\n                    tag_fn = lambda x: 0.99**np.arange(x, -1, -1)\n                    weight_fn = tag_fn\n                else:\n                    tag_fn = lambda x: np.array([1.]*(x + 1))\n                    weight_fn = tag_fn\n                out = nexcp_split(\n                    model=sm.WLS,\n                    split_function=split_fn,\n                    y=y_model,\n                    X=X_model,\n                    tag_function=tag_fn,\n                    weight_function=weight_fn,\n                    alpha=0.1,\n                    test_index=i\n                )\n                out[\"method\"] = method\n                out[\"dataset\"] = dataset\n                out[\"index\"] = i\n                del out[\"ci\"]\n                results.append(out)\n```\n:::\n\n\n#### Plots\n\n::: {#b68939b8 .cell layout-ncol='2' execution_count=8}\n``` {.python .cell-code}\ncoverage_plot = plot_rolling_coverage(\n    results,\n    alpha=0.1,\n    window=10,\n    rows=3,\n    repeated=True\n)\ncoverage_plot.show()\n\nwidth_plot = plot_rolling_width(results, window=10, rows=3, repeated=True)\nwidth_plot.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-9-output-1.png){width=640 height=480 fig-align='center'}\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-9-output-2.png){width=640 height=480 fig-align='center'}\n:::\n:::\n\n\n#### Table\n\n::: {#64b301ed .cell execution_count=9}\n``` {.python .cell-code}\ntable = (\n    pd\n    .DataFrame(results)\n    .groupby([\"method\", \"dataset\", \"index\"])\n    .mean()\n    .reset_index()\n    .drop(labels=[\"index\"], axis=1)\n    .groupby([\"method\", \"dataset\"])\n    .mean()\n    .reset_index()\n)\ntable = (\n    table\n    .pivot_table(\n        index=\"method\",\n        columns=\"dataset\",\n        values=[\"covered\", \"width\"]\n    )\n)\ntable.columns = [f\"{col[0]}_{col[1].lower()}\" for col in table.columns]\ntable = table.reset_index()\ntable = (\n    GT(table, rowname_col=\"method\")\n    .tab_spanner(\n        label=\"Setting 1 (i.i.d. data)\",\n        columns=[\"covered_setting_1\", \"width_setting_1\"]\n    )\n    .tab_spanner(\n        label=\"Setting 2 (changepoints)\",\n        columns=[\"covered_setting_2\", \"width_setting_2\"]\n    )\n    .tab_spanner(\n        label=\"Setting 3 (drift)\",\n        columns=[\"covered_setting_3\", \"width_setting_3\"]\n    )\n    .fmt_number(\n        columns = [\n            \"covered_setting_1\",\n            \"width_setting_1\",\n            \"covered_setting_2\",\n            \"width_setting_2\",\n            \"covered_setting_3\",\n            \"width_setting_3\"\n        ],\n        decimals=3\n    )\n    .cols_label(\n        covered_setting_1 = \"Coverage\",\n        width_setting_1 = \"Width\",\n        covered_setting_2 = \"Coverage\",\n        width_setting_2 = \"Width\",\n        covered_setting_3 = \"Coverage\",\n        width_setting_3 = \"Width\"\n    )\n)\ntable.show()\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div id=\"zqbkcjygmy\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>\n#zqbkcjygmy table {\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif;\n          -webkit-font-smoothing: antialiased;\n          -moz-osx-font-smoothing: grayscale;\n        }\n\n#zqbkcjygmy thead, tbody, tfoot, tr, td, th { border-style: none; }\n tr { background-color: transparent; }\n#zqbkcjygmy p { margin: 0; padding: 0; }\n #zqbkcjygmy .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; }\n #zqbkcjygmy .gt_caption { padding-top: 4px; padding-bottom: 4px; }\n #zqbkcjygmy .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; }\n #zqbkcjygmy .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; }\n #zqbkcjygmy .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; }\n #zqbkcjygmy .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; }\n #zqbkcjygmy .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; }\n #zqbkcjygmy .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; }\n #zqbkcjygmy .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; }\n #zqbkcjygmy .gt_column_spanner_outer:first-child { padding-left: 0; }\n #zqbkcjygmy .gt_column_spanner_outer:last-child { padding-right: 0; }\n #zqbkcjygmy .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; }\n #zqbkcjygmy .gt_spanner_row { border-bottom-style: hidden; }\n #zqbkcjygmy .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; }\n #zqbkcjygmy .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; }\n #zqbkcjygmy .gt_from_md> :first-child { margin-top: 0; }\n #zqbkcjygmy .gt_from_md> :last-child { margin-bottom: 0; }\n #zqbkcjygmy .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; }\n #zqbkcjygmy .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; }\n #zqbkcjygmy .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; }\n #zqbkcjygmy .gt_row_group_first td { border-top-width: 2px; }\n #zqbkcjygmy .gt_row_group_first th { border-top-width: 2px; }\n #zqbkcjygmy .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; }\n #zqbkcjygmy .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; }\n #zqbkcjygmy .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; text-align: left; }\n #zqbkcjygmy .gt_left { text-align: left; }\n #zqbkcjygmy .gt_center { text-align: center; }\n #zqbkcjygmy .gt_right { text-align: right; font-variant-numeric: tabular-nums; }\n #zqbkcjygmy .gt_font_normal { font-weight: normal; }\n #zqbkcjygmy .gt_font_bold { font-weight: bold; }\n #zqbkcjygmy .gt_font_italic { font-style: italic; }\n #zqbkcjygmy .gt_super { font-size: 65%; }\n #zqbkcjygmy .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; }\n #zqbkcjygmy .gt_asterisk { font-size: 100%; vertical-align: 0; }\n \n</style>\n<table class=\"gt_table\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n\n<tr class=\"gt_col_headings gt_spanner_row\">\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"2\" colspan=\"1\" scope=\"col\" id=\"\"></th>\n  <th class=\"gt_center gt_columns_top_border gt_column_spanner_outer\" rowspan=\"1\" colspan=\"2\" scope=\"colgroup\" id=\"Setting 1 (i.i.d. data)\">\n    <span class=\"gt_column_spanner\">Setting 1 (i.i.d. data)</span>\n  </th>\n  <th class=\"gt_center gt_columns_top_border gt_column_spanner_outer\" rowspan=\"1\" colspan=\"2\" scope=\"colgroup\" id=\"Setting 2 (changepoints)\">\n    <span class=\"gt_column_spanner\">Setting 2 (changepoints)</span>\n  </th>\n  <th class=\"gt_center gt_columns_top_border gt_column_spanner_outer\" rowspan=\"1\" colspan=\"2\" scope=\"colgroup\" id=\"Setting 3 (drift)\">\n    <span class=\"gt_column_spanner\">Setting 3 (drift)</span>\n  </th>\n</tr>\n<tr class=\"gt_col_headings\">\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"Coverage\">Coverage</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"Width\">Width</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"Coverage\">Coverage</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"Width\">Width</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"Coverage\">Coverage</th>\n  <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" scope=\"col\" id=\"Width\">Width</th>\n</tr>\n<tbody class=\"gt_table_body\">\n  <tr>\n    <th class=\"gt_row gt_left gt_stub\">CP+LS</th>\n    <td class=\"gt_row gt_right\">0.898</td>\n    <td class=\"gt_row gt_right\">3.300</td>\n    <td class=\"gt_row gt_right\">0.828</td>\n    <td class=\"gt_row gt_right\">5.982</td>\n    <td class=\"gt_row gt_right\">0.835</td>\n    <td class=\"gt_row gt_right\">3.730</td>\n  </tr>\n  <tr>\n    <th class=\"gt_row gt_left gt_stub\">NexCP+LS</th>\n    <td class=\"gt_row gt_right\">0.896</td>\n    <td class=\"gt_row gt_right\">3.303</td>\n    <td class=\"gt_row gt_right\">0.842</td>\n    <td class=\"gt_row gt_right\">6.127</td>\n    <td class=\"gt_row gt_right\">0.853</td>\n    <td class=\"gt_row gt_right\">3.905</td>\n  </tr>\n  <tr>\n    <th class=\"gt_row gt_left gt_stub\">NexCP+WLS</th>\n    <td class=\"gt_row gt_right\">0.898</td>\n    <td class=\"gt_row gt_right\">3.322</td>\n    <td class=\"gt_row gt_right\">0.923</td>\n    <td class=\"gt_row gt_right\">5.363</td>\n    <td class=\"gt_row gt_right\">0.912</td>\n    <td class=\"gt_row gt_right\">3.573</td>\n  </tr>\n</tbody>\n\n\n</table>\n\n</div>\n        \n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}